# Загрузка (loading) и стриминг (streaming)

[Оригинал статьи](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)

Актуальность: 12.03.2024

---

Специальный файл `loading.js` помогает создавать осмысленные пользовательские интерфейсы загрузки (лоадеры) с помощью `React Suspense`. С его помощью вы можете показать состояние текущей загрузки с сервера (лоадер), пока загружается содержимое сегмента роута. Новый контент автоматически подставляется после завершения рендеринга.

![](images/routing/loading-ui.avif)

## Состояния мгновенной загрузки

Лоадер - это резервный пользовательский интерфейс (компонент лоадера), который отображается сразу после навигации. Вы можете предварительно отрендерить лоадеры, такие как скелетон (skeleton) и спиннер (spinner), или небольшую, но значимую часть будущих UI интерфейсов, например фотографию обложки, заголовок и т. д. Это поможет пользователям понять, что приложение реагирует на действие (выполняется некий процесс), и обеспечит лучший UX (пользовательский опыт).

Создайте компонент лоадера, добавив файл `loading.js` в папку.

![](images/routing/loading-special-file.avif)

```tsx
// loading.tsx

export default function Loading() {
  // You can add any UI inside Loading, including a Skeleton.
  return <LoadingSkeleton />
}
```

В той же папке файл `loading.js` будет вложен внутрь `layout.js`. Он автоматически обернет файл `page.js` и все дочерние файлы ниже в границу `<Suspense>`.

![](images/routing/loading-overview.avif)

Полезно знать:
* Навигация осуществляется мгновенно, даже при [серверно-ориентированной маршрутизации](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#how-routing-and-navigation-works) (роутинге).
* Навигация не прерывается, то есть при изменении роута (навигации по страницам) не нужно ждать полной загрузки содержимого роута, прежде чем переходить к другому роуту.
* Общие макеты (layout) остаются интерактивными, пока загружаются новые сегменты роута.

Рекомендации: Используйте соглашения `loading.js` для сегментов роута (`layout` и `page`), поскольку Next.js оптимизирует эту функциональность.

## Потоковая передача с помощью Suspense

Помимо `loading.js`, вы можете вручную создавать границы `Suspense Boundaries` для собственных компонентов пользовательского интерфейса. App Router поддерживает потоковую передачу с `Suspense` как для Node.js, так и для `Edge runtimes`.

#### Что такое стриминг?

Чтобы понять, как работает стриминг в React и Next.js, полезно разобраться с рендерингом на стороне сервера (Server-Side Rendering, SSR) и его ограничениями.

В SSR есть ряд шагов, которые должны быть выполнены, прежде чем пользователь сможет увидеть страницу и взаимодействовать с ней:

1. Сначала все данные для данной страницы собираются на сервере.
2. Затем сервер создает HTML код страницы.
3. HTML, CSS и JavaScript для страницы отправляются на клиент (браузер).
4. Неинтерактивный пользовательский интерфейс (UI, с которым нет возможности взаимодействовать) отображается с помощью сгенерированных HTML и CSS.
5. И наконец, React добавляет в пользовательский интерфейс интерактивность.

![](images/routing/server-rendering-without-streaming-chart.avif)

Эти шаги являются последовательными и блокирующими, то есть сервер отрендерить HTML страницы только после того, как все данные будут получены. А на клиенте React может гидрировать код (добавить функциональность и данные) всех компонентов страницы только после загрузки всех файлов.

SSR с React и Next.js помогает повысить производительность загрузки, показывая пользователю неинтерактивную страницу как можно быстрее.

![](images/routing/server-rendering-without-streaming.avif)

Однако он все равно может быть медленным, так как перед тем, как показать страницу пользователю, необходимо выполнить все действия по сбору данных на сервере.

Потоковая передача позволяет разбить HTML страницы на более мелкие фрагменты и постепенно передавать эти фрагменты с сервера на клиент.

![](images/routing/server-rendering-with-streaming.avif)

Это позволяет отображать части страницы раньше, не дожидаясь загрузки всех данных до того, как будет отображен пользовательский интерфейс.

Потоковая передача хорошо работает с компонентной моделью React, поскольку каждый компонент можно рассматривать как чанк (отдельный кусок кода). Компоненты с более высоким приоритетом (например, информация о продукте) или не зависящие от данных, могут быть отправлены первыми (например, `layout`), и React сможет начать гидратацию раньше. Компоненты с более низким приоритетом (например, отзывы, сопутствующие товары) могут быть отправлены в том же запросе сервера после получения данных о них.

![](images/routing/server-rendering-with-streaming-chart.avif)

Потоковая передача данных особенно полезна, когда вы хотите предотвратить блокировку страницы при длинных запросах данных (больших объемах данных), поскольку она позволяет сократить время до первого байта ([TTFB](https://web.dev/ttfb/)) и первого контентного рисунка ([FCP](https://web.dev/first-contentful-paint/)). Она также помогает улучшить показатель время до взаимодействия с пользователем ([TTI](https://developer.chrome.com/en/docs/lighthouse/performance/interactive/)), особенно на медленных устройствах.


### Пример

`<Suspense>` работает, оборачивая компонент, выполняющий асинхронное действие (например, получение данных), показывая резервный пользовательский интерфейс (например, скелетон или спиннер), пока это длится, а затем подменяя ваш компонент после завершения действия.

```tsx
// page.tsx

import { Suspense } from 'react'
import { PostFeed, Weather } from './Components'

export default function Posts() {
    return (
        <section>
            <Suspense fallback={<p>Loading feed...</p>}>
                <PostFeed />
            </Suspense>
            <Suspense fallback={<p>Loading weather...</p>}>
                <Weather />
            </Suspense>
        </section>
    )
}
```

Используя `Suspense`, вы получаете следующие преимущества:

1. **Потоковый серверный рендеринг** (Streaming Server Rendering) - постепенный рендеринг HTML и передача с сервера на клиент.
2. **Выборочная гидратация** (Selective Hydration) - React определяет приоритетность компонентов, которые следует сделать интерактивными (гидрировать) в первую очередь, на основе взаимодействия с пользователем.

Другие примеры и сценарии использования `Suspense` можно найти в документации [React](https://react.dev/reference/react/Suspense).

### SEO

Next.js будет ждать завершения выборки данных в `generateMetadata`, прежде чем передать UI клиенту. Это гарантирует, что первая часть потокового ответа будет включать теги `<head>`.

Поскольку потоковая передача (стриминг) является серверной, она не влияет на SEO. Вы можете использовать инструмент [Rich Results Test](https://search.google.com/test/rich-results) от Google, чтобы увидеть, как ваша страница отображается для веб-краулеров Google (пауков аналитики seo), и просмотреть сериализованный HTML ([источник](https://web.dev/rendering-on-the-web/#seo-considerations)).

### Коды состояния (Status Codes)

При потоковой передаче возвращается код состояния (статус код) 200, сигнализирующий об успешном выполнении запроса.

Сервер все еще может сообщать клиенту об ошибках или проблемах в самом потоковом контенте, например, при использовании переадресации (redirect) или notFound. Поскольку заголовки ответа уже отправлены клиенту, код состояния ответа не может быть обновлен. Это не влияет на SEO.


